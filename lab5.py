import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from scipy.linalg import solve
import warnings


def table(df):
    df['Первые разности'] = df['y'].diff()
    df['Вторые разности'] = df['Первые разности'].diff()
    df['Третьи разности'] = df['Вторые разности'].diff()
    df['Четвертые разности'] = df['Третьи разности'].diff()
    df['Пятые разности'] = df['Четвертые разности'].diff()
    df['Шестые разности'] = df['Пятые разности'].diff()
    df['Седьмые разности'] = df['Шестые разности'].diff()
    df['Восьмые разности'] = df['Седьмые разности'].diff()
    df['Девятые разности'] = df['Восьмые разности'].diff()
    
    return df

def interp():  # простая экстраполяция в +- 2 узла
    x = np.array([12.0, 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13.0])
    y = np.array([0.000357, -1.12952, -2.15806, -2.98314, -3.52184, -3.71872, -3.55153, -3.03371, -2.21331, -1.16858, -0.00055])

    x_1 = np.linspace(x[0]-0.2, x[-1]+0.2, len(x) + 4)  # Новые значения аргумента для экстраполяции
    f = interp1d(x,y, kind = 'quadratic', fill_value='extrapolate')  # Квадратичная интерполяция

    y_1 = f(x_1)
    data1 = {
        'x': x_1,
        'y': y_1
    }

    print("---------------------------")
    print("экстраполированные значения")
    df1 = pd.DataFrame(data1)
    print(df1)

def lagrange_interpolation(x, y, x_new):  # Интерполяция Лагранжа в полузлах
    n = len(x)  # Количество узлов
    m = len(x_new)  # Количество новых точек
    y_new = np.zeros(m)  # Массив для новых значений функции
    
    for j in range(m):
        for i in range(n):
            p = 1
            for k in range(n):
                if k != i:  # Пропускаем i-й узел
                    p *= (x_new[j] - x[k]) / (x[i] - x[k])  # Вычисляем базисный многочлен
            y_new[j] += y[i] * p  # Суммируем значения функции в узлах
    
    return y_new

def divided_differences(x, y):  # Таблица конечных разностей для интерполяции Ньютона
  n = len(x)  # Количество узлов
  coeffs = np.zeros((n, n))  # Массив для конечных разностей
  coeffs[:, 0] = y  # Заполняем первый столбец значениями функции

  for j in range(1, n):
    for i in range(n-j):
      coeffs[i, j] = (coeffs[i+1, j-1] - coeffs[i, j-1]) / (x[i+j] - x[i])  # Вычисляем конечные разности

  return coeffs

def newton_forward(x, y, x_new):  # Интерполяция Ньютона вперед
  n = len(x) # Количество узлов
  coeffs = divided_differences(x, y) # Таблица конечных разностей
  s = coeffs[0, 0]  # Первое значение интерполяции
  p = 1  # Базисный многочлен

  for i in range(1, n):
    p *= (x_new - x[i-1])  # Вычисляем базисный многочлен
    s += p * coeffs[0, i]  # Суммируем значения функции
  
  return s

def newton_backward(x, y, x_new): # Интерполяция Ньютона назад
  n = len(x)  # Количество узлов
  coeffs = divided_differences(x, y)  # Таблица конечных разностей
  s = coeffs[-1, -1]  # Первое значение интерполяции
  p = 1  # Базисный многочлен

  for i in range(1, n):
    p *= (x_new - x[n-i])  # Вычисляем базисный многочлен
    s += p * coeffs[n-i-1, i]  # Суммируем значения функции
  
  return s

def quadratic_spline(x, y):  # Квадратичный сплайн
  n = len(x)  # Количество узлов
  h = np.diff(x)  # Шаги между узлами
  a = np.zeros(n)  # Коэффициенты сплайна
  b = np.zeros(n-1)  # Коэффициенты сплайна
  d = np.zeros(n-1)  # Коэффициенты сплайна

  # Вычисление коэффициентов
  a[0] = y[0]
  for i in range(1, n-1):
      a[i] = y[i] 
      b[i-1] = (y[i] - y[i-1]) / h[i-1] - h[i-1] / 3 * (a[i-1] + 2*a[i])
  
  a[-1] = y[-1]
  b[-1] = (y[-1] - y[-2]) / h[-1] - 2/3 * h[-1] * a[-1]

  def spline(x_new):  # Функция сплайна
      i = np.searchsorted(x, x_new) - 1  # Находим отрезок, в котором находится x_new
      i = i[-1] 
      if i == n-1:
          i -= 1
      return a[i] + b[i] * (x_new - x[i]) + 0.5 * (b[i] - b[i-1]) / h[i] * (x_new - x[i])**2
  
  return spline

def trigonometric_approximation(x, y, degree=3):  # Тригонометрическая аппроксимация
    n = len(x)  # Количество узлов
    A = np.zeros((2*degree+1, 2*degree+1))  # Матрица системы
    B = np.zeros(2*degree+1)  # Вектор свободных членов
    
    for k in range(2*degree+1):
        B[k] = np.sum(y * np.exp(-1j * k * x))  # Вычисляем вектор свободных членов
        for m in range(2*degree+1):
            A[k, m] = np.sum(np.exp(-1j * (k-m) * x))  # Вычисляем матрицу системы
    
    C = solve(A, B)  # Решаем систему
    
    def approx(x_new):  # Функция аппроксимации
        s = 0
        for k in range(2*degree+1):
            s += C[k] * np.exp(1j * k * x_new)  # Суммируем значения функции
        return s.real  # Возвращаем действительную часть
    
    return approx

def quadratic_approximation(x, y):  # Квадратичная аппроксимация
    n = len(x)  # Количество узлов
    A = np.zeros((3, 3))  # Матрица системы
    B = np.zeros(3)  # Вектор свободных членов
    
    A[0, 0] = n
    A[0, 1] = np.sum(x)
    A[0, 2] = np.sum(x**2)
    A[1, 0] = A[0, 1]
    A[1, 1] = A[0, 2]
    A[1, 2] = np.sum(x**3)
    A[2, 0] = A[1, 1]
    A[2, 1] = A[1, 2]
    A[2, 2] = np.sum(x**4)
    
    B[0] = np.sum(y)
    B[1] = np.sum(x*y)
    B[2] = np.sum(x**2*y)
    
    C = solve(A, B)  # Решаем систему
    
    def approx(x_new):  # Функция аппроксимации
        return C[0] + C[1]*x_new + C[2]*x_new**2  # Возвращаем значение функции
    
    return approx

def cubic_approximation(x, y):  # Кубическая аппроксимация
    n = len(x)  # Количество узлов
    A = np.zeros((4, 4))  # Матрица системы
    B = np.zeros(4)  # Вектор свободных членов
    
    A[0, 0] = n
    A[0, 1] = np.sum(x)
    A[0, 2] = np.sum(x**2)
    A[0, 3] = np.sum(x**3)
    A[1, 0] = A[0, 1]
    A[1, 1] = A[0, 2]
    A[1, 2] = A[0, 3]
    A[1, 3] = np.sum(x**4)
    A[2, 0] = A[1, 1]
    A[2, 1] = A[1, 2]
    A[2, 2] = A[1, 3]
    A[2, 3] = np.sum(x**5)
    A[3, 0] = A[2, 1]
    A[3, 1] = A[2, 2]
    A[3, 2] = A[2, 3]
    A[3, 3] = np.sum(x**6)
    
    B[0] = np.sum(y)
    B[1] = np.sum(x*y)
    B[2] = np.sum(x**2*y)
    B[3] = np.sum(x**3*y)
    
    C = solve(A, B)  # Решаем систему
    
    def approx(x_new):  # Функция аппроксимации
        return C[0] + C[1]*x_new + C[2]*x_new**2 + C[3]*x_new**3  # Возвращаем значение функции
    
    return approx


def bld1(x, y, x_new, y_new):  # Визуализация кваадратичного сплайна
    plt.subplot(2, 2, 1)
    plt.plot(x, y, 'o', label='Исходные данные')
    plt.plot(x_new, y_new, '-', label='Экстраполяция')
    
    plt.title("Квадратичный сплайн")
    plt.legend()
    plt.minorticks_on()  # включаем отображение дополнительных отсечек сетки
    plt.grid(which = 'major')  # включаем основную сетку
    plt.grid(which = 'minor', linestyle = ':')  # включаем дополнительную сетку

    plt.tight_layout()  # включаем автоматическое красивое отображение
    #return plt.show()

def bld2(x, y, x_new, y_new):  # Визуализация тригонометрической аппроксимации
    plt.subplot(2, 2, 2)
    plt.plot(x, y, 'o', label='Исходные данные')
    plt.plot(x_new, y_new, '-', label='Экстраполяция')

    plt.title("Тригонометрическая аппроксимация")
    plt.legend()
    plt.minorticks_on()  # включаем отображение дополнительных отсечек сетки
    plt.grid(which = 'major')  # включаем основную сетку
    plt.grid(which = 'minor', linestyle = ':')  # включаем дополнительную сетку

    plt.tight_layout()  # включаем автоматическое красивое отображение
    #return plt.show()

def bld3(x, y, x_new, y_new):  # Визуализация квадратичной аппроксимации
    plt.subplot(2, 2, 3)
    plt.plot(x, y, 'o', label='Исходные данные')
    plt.plot(x_new, y_new, '-', label='Экстраполяция')

    plt.title("Квадратичная аппроксимация")
    plt.legend()
    plt.minorticks_on()  # включаем отображение дополнительных отсечек сетки
    plt.grid(which = 'major')  # включаем основную сетку
    plt.grid(which = 'minor', linestyle = ':')  # включаем дополнительную сетку

    plt.tight_layout()  # включаем автоматическое красивое отображение
    #return plt.show()

def bld4(x, y, x_new, y_new):  # Визуализация кубической аппроксимации
    plt.subplot(2, 2, 4)
    plt.plot(x, y, 'o', label='Исходные данные')
    plt.plot(x_new, y_new, '-', label='Экстраполяция')

    plt.title("Кубическая аппроксимация")
    plt.legend()
    plt.minorticks_on()  # включаем отображение дополнительных отсечек сетки
    plt.grid(which = 'major')  # включаем основную сетку
    plt.grid(which = 'minor', linestyle = ':')  # включаем дополнительную сетку

    plt.tight_layout()  # включаем автоматическое красивое отображение
    #return plt.show()

if __name__ == '__main__':  # Точка входа
    warnings.filterwarnings("ignore")  # Игнорируем предупреждения

    data = {
    'x': [12.0, 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13.0],
    'y': [0.000357, -1.12952, -2.15806, -2.98314, -3.52184, -3.71872, -3.55153, -3.03371, -2.21331, -1.16858, -0.00055]
    }
    

    # --------------------------------
    # работаем с разностями
    df = pd.DataFrame(data)  # Создаем DataFrame
    df = table(df)  # Добавляем столбцы с разностями
    print(df)  # Выводим таблицу
    # работаем с интерполяцией и экстраполяцией
    interp()
    

    # --------------------------------
    # работаем с интерполяцией Лагранжа
    x = np.array(data['x'])  # Узлы интерполяции
    y = np.array(data['y'])  # Значения функции в узлах
    x_new = np.array([12.05, 12.15, 12.25, 12.35, 12.45, 12.55, 12.65, 12.75, 12.85, 12.95])  # Новые значения аргумента для интерполяции
    y_new = lagrange_interpolation(x, y, x_new)  # Вычисляем значения функции в новых точках
    data2 = {
        'x': x_new,
        'y': y_new
    }
    print("---------------------------")
    print("интерполированные значения по Лагранжу")
    df2 = pd.DataFrame(data2)
    print(df2)


    # --------------------------------
    # работаем с интерполяцией Ньютона
    x = np.array(data['x'])  # Узлы интерполяции
    y = np.array(data['y'])  # Значения функции в узлах
    x_new_fow = 12.23 # Новые значения аргумента для интерполяции вперед
    x_new_bac = 12.79 # Новые значения аргумента для интерполяции назад
    y_new_fow = newton_forward(x, y, x_new_fow)  # Вычисляем значения функции в новых точках вперед
    y_new_bac = newton_backward(x, y, x_new_bac)  # Вычисляем значения функции в новых точках назад
    print("---------------------------")
    print("интерполированные значения по Ньютону вперед")
    print("x = ", x_new_fow)
    print("y = ", y_new_fow)
    print("---------------------------")
    print("интерполированные значения по Ньютону назад")
    print("x = ", x_new_bac)
    print("y = ", y_new_bac)


    # --------------------------------
    # работаем с квадратичной сплайн-интерполяцией
    x = np.array([12.0, 12.1, 12.2, 12.3, 12.4])
    y = np.array([0.000357, -1.12952, -2.15806, -2.98314, -3.52184])
    x_new = np.array([12.0, 12.05, 12.1, 12.15, 12.2, 12.25, 12.3, 12.35, 12.4, 12.45])  # Новые значения аргумента для интерполяции
    
    f = quadratic_spline(x, y)  # Создаем сплайн
    
    y_new = f(x_new)  # Вычисляем значения функции в новых точках
    data3 = {
        'x': x_new,
        'y': y_new
    }
    print("---------------------------")
    print("интерполированные значения по квадратичному сплайну")
    df3 = pd.DataFrame(data3)
    print(df3)
    bld1(x, y, x_new, y_new)  # Визуализация


    # --------------------------------
    # работаем с тригонометрической аппроксимацией
    x = np.array([12.0, 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13.0])
    y = np.array([0.000357, -1.12952, -2.15806, -2.98314, -3.52184, -3.71872, -3.55153, -3.03371, -2.21331, -1.16858, -0.00055])
    approx = trigonometric_approximation(x, y, degree = 3)  # Создаем аппроксимацию
    x_new = np.array([12.0, 12.05, 12.1, 12.15, 12.2, 12.25, 12.3, 12.35, 12.4, 12.45, 12.5, 12.55, 12.6, 12.65, 12.7, 12.75, 12.8, 12.85, 12.9, 12.95, 13.0])  # Новые значения аргумента для аппроксимации 
    y_new = approx(x_new)  # Вычисляем значения функции в новых точках
    data4 = {
        'x': x_new,
        'y': y_new
    }
    print("---------------------------")
    print("аппроксимированные значения по тригонометрической аппроксимации")
    df4 = pd.DataFrame(data4)
    print(df4)
    bld2(x, y, x_new, y_new)  # Визуализация


    # --------------------------------
    # работаем с квадратичной аппроксимацией
    x = np.array([12.0, 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13.0])
    y = np.array([0.000357, -1.12952, -2.15806, -2.98314, -3.52184, -3.71872, -3.55153, -3.03371, -2.21331, -1.16858, -0.00055])
    approx = quadratic_approximation(x, y)  # Создаем аппроксимацию
    x_new = np.array([12.0, 12.05, 12.1, 12.15, 12.2, 12.25, 12.3, 12.35, 12.4, 12.45, 12.5, 12.55, 12.6, 12.65, 12.7, 12.75, 12.8, 12.85, 12.9, 12.95, 13.0])  # Новые значения аргумента для аппроксимации
    y_new = approx(x_new)  # Вычисляем значения функции в новых точках
    data5 = {
        'x': x_new,
        'y': y_new
    }
    print("---------------------------")
    print("аппроксимированные значения по квадратичной аппроксимации")
    df5 = pd.DataFrame(data5)
    print(df5)
    bld3(x, y, x_new, y_new)  # Визуализация
    

    # --------------------------------
    # работаем с кубической аппроксимацией
    x = np.array([12.0, 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13.0])
    y = np.array([0.000357, -1.12952, -2.15806, -2.98314, -3.52184, -3.71872, -3.55153, -3.03371, -2.21331, -1.16858, -0.00055])
    approx = cubic_approximation(x, y)  # Создаем аппроксимацию
    x_new = np.array([12.0, 12.05, 12.1, 12.15, 12.2, 12.25, 12.3, 12.35, 12.4, 12.45, 12.5, 12.55, 12.6, 12.65, 12.7, 12.75, 12.8, 12.85, 12.9, 12.95, 13.0])  # Новые значения аргумента для аппроксимации
    y_new = approx(x_new)  # Вычисляем значения функции в новых точках
    data6 = {
        'x': x_new,
        'y': y_new
    }
    print("---------------------------")
    print("аппроксимированные значения по кубической аппроксимации")
    df6 = pd.DataFrame(data6)
    print(df6)
    bld4(x, y, x_new, y_new)  # Визуализация

    plt.show()

