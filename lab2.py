import numpy as np
import matplotlib.pyplot as plt

def phi(x):  # функция описывающая приведённую левую часть для первого метода
  return 1 + np.sin(x) - np.log(1 + x) 

def f(x):  # функция описывающая нормальную левую часть для второго и третьего методов
  return 1 - x + np.sin(x) - np.log(1 + x)

def df(x):  # производная функции для третьего метода
  return -1 + np.cos(x) - 1 / (1 + x)


def iteration_method(x0, eps, max_iter):  # итерационный метод
  x = x0
  for i in range(max_iter):  # заходим в шаг итерации
    xit = phi(x)  # x итерируемое - значение приведённой функции от x
    if abs(xit - x) < eps:  # если диапазон между x и x итерируемое меньше приближения то заканчиваем работу
      return xit
    x = xit  # если диапазон больше меняем x на x итерируемое и идём дальше пока не закончатся итерации
  print("Превышено максимальное число итераций") 
  return None  # если итерации закончились то выходим


def bisection_method(a, b, eps):  # метод половинного деления
  if f(a) * f(b) >= 0:  # проверим поменялся ли знак если нет - выходим
    print("Функция не меняет знак на отрезке [a, b]")
    return None
  
  while (b - a) / 2 > eps:  # если знак поменялся и длина отрезка не меньше заданной точности
    c = (a + b) / 2  # начинаем делить отрезок пополам
    if f(c) == 0:
      return c
    elif f(a) * f(c) < 0:  # определяем с какой стороны от центра расположена граница a
      b = c
    else:
      a = c

  return (a + b) / 2  # возвращаем среднее значение отрезка как близкое к точному


def newton_method(x0, eps, max_iter):  # метод ньютона
  for i in range(max_iter):  # похоже на итерационный метод - заходим на шаг итерации
    xit = x0 - f(x0) / df(x0)  # более точно считаем x итерируемое
    if abs(xit - x0) < eps:  # снова если диапазон меньше приближения то выходим
      return xit
    x0 = xit  # если диапазон больше меняем x на x итерируемое и идём дальше пока не закончатся итерации
  print("Превышено максимальное число итераций")
  return None  # если итерации закончились то выходим


def bld(root2):  # строим график функции в диапазоне учитывающем её область определения
  yroot = 0

  x = np.linspace(-0.9, 2, 100)
  x1 = np.linspace(-1, 2, 100)
  x2 = np.linspace(-1, 4, 100)
  y = f(x)
  y1 = x*0

  plt.plot(x, y, '--r')  # строим график
  plt.plot(x1,y1,'k')  # строим вспомогательную ось
  plt.plot(y1,x2, 'k')  # строим вспомогательную ось
  plt.plot(root2, yroot, 'ob')  # отметили корень

  plt.xlabel('x', fontsize = 16)  # подписываем оси
  plt.ylabel('y', fontsize = 16)
  plt.title('График функции y = 1 - x + sin(x) - ln(1+x)')  # подписываем график
  
  plt.minorticks_on()  # включаем отображение дополнительных отсечек сетки
  plt.grid(which = 'major')  # включаем основную сетку
  plt.grid(which = 'minor', linestyle = ':')  # включаем дополнительную сетку

  plt.tight_layout()  # включаем автоматическое красивое отображение
  return plt.show()

if __name__ == "__main__":  # точка входа 
  # задаем начальное приближение, точность и максимальное число итераций
  x0 = 0.5  # начальное приближение для итерируемых методов
  eps = 1e-4  # заданная точность вычислений
  max_iter = 100  # максимальное число шагов итерации
  a = 0  # границы отрезка для метода половинного деления - левая
  b = 2  # правая граница

  # вызываем функции для решения уравнения
  root = iteration_method(x0, eps, max_iter)  # запускаем итерационный метод
  root1 = bisection_method(a, b, eps)  # запускаем метод половинного деления
  root2 = newton_method(x0, eps, max_iter)  # запускаем метод ньютона

  if root is not None:
    print("Корень уравнения, первый метод:", root)

  if root1 is not None:
    print("Корень уравнения, второй метод:", root1)

  if root2 is not None:
    print("Корень уравнения, третий метод:", root2)

  bld(root2)  # включили визуализацию
  